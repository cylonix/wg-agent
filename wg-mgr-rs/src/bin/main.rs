// Copyright (c) EZBLOCK INC. & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

#![allow(missing_docs)]
#[macro_use]
extern crate log;
extern crate pretty_env_logger;

use clap::{Arg, Command};
use std::sync::Arc;
use tokio::sync::Mutex;
use futures::StreamExt;
use wg_mgr_rs::wg_api_server;
use wg_mgr_rs::wg_conf_server;
use wg_mgr_rs::wg_conf_store_srv;
use wg_mgr_rs::wg_network_conf_srv;

use crate::wg_conf_store_srv::get_hostname;
use etcd_rs::{KeyRange, WatchOp};
use futures::future::join_all;
use std::time::Duration;
use tokio::task;
use tokio::time;

const NODE_STR: &str = "http://127.0.0.1:2379";

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
#[tokio::main]
async fn main() {
    pretty_env_logger::init();

    info!("Cylonix Wireguard agent starting...");
    let iproute = wg_network_conf_srv::NetworkConfClient::new();
    let iproute = Arc::new(Mutex::new(iproute));

    let matches = Command::new("server")
        .arg(
            Arg::new("https")
                .long("https")
                .help("Whether to use HTTPS or not")
                .action(clap::ArgAction::SetTrue)
        )
        .arg(
            Arg::new("etcd")
                .long("etcd")
                .default_value(NODE_STR)
                .value_name("ETCD_ADDR")
                .help("etcd client addr")
        )
        .get_matches();

    let mut node_addr = String::from(NODE_STR);
    if let Some(ns) = matches.get_one::<String>("etcd") {
        node_addr = String::from(ns);
        info!("Using the customized etcd address {}", ns);
    }

    // connect to the etcd server
    info!("Connecting to etcd server {}", node_addr);
    let etcd_client = wg_conf_store_srv::EtcdClientConfig::new(&vec![node_addr.as_str()])
        .connect()
        .await;
    match etcd_client {
        None => {
            error!("Cannot connect to etcd server, is it running?");
            panic!("Etcd connect failed!");
        }
        Some(_) => {
            warn!("Etcd connected!(currently, since we use not auth configuration, we can not check if we connected to the db truly!)")
        }
    }

    let etcd_client = etcd_client.unwrap();
    let api_etcd_client = etcd_client.clone();
    let api_ip_service = iproute.clone();
    let wg_api_server = task::spawn(async {
        let addr = "0.0.0.0:8080";
        info!("Wireguard agent server listening on {}", addr);
        match wg_api_server::create(addr, api_etcd_client, api_ip_service).await {
            Ok(_) => info!("Wireguard API server started successfully!"),
            Err(e) => {
                panic!("Failed to start Wireguard API server: {}", e);
            }
        };
    });

    let sample_timer = task::spawn(async {
        let mut interval = time::interval(Duration::from_secs(2));

        loop {
            interval.tick().await;

            trace!("Timer expire!");
        }
    });

    // Create the etcd watch task
    let hostname = get_hostname().unwrap();
    let prefix = format!(
        "/wg/{hostname}/namespace/configuration",
        hostname = hostname
    );
    
    let watch_result = etcd_client.watch(KeyRange::prefix(prefix)).await;
    let mut inbound = match watch_result {
        Ok((watch_stream, _canceler)) => watch_stream,
        Err(e) => {
            error!("Failed to create etcd watch: {}", e);
            panic!("Etcd watch failed!");
        }
    };
    
    // print out all received watch responses
    let watch_server = tokio::spawn(async move {
        while let Some(resp) = inbound.next().await {
            debug!("watch response: {:?}", resp);
        }
    });

    // configuration server
    let config_etcd_client = etcd_client.clone();
    let config_ip_service = iproute.clone();
    let config_server = task::spawn(async {
        info!("Configuration services start...");
        wg_conf_server::create(config_etcd_client, config_ip_service).await;
    });

    let futures = vec![wg_api_server, sample_timer, watch_server, config_server];
    join_all(futures).await;
}